# 10章 ファイルシステムの最深部を扱うGo言語の関数

> OSパッケージだけでは実現できない、少し高度なファイル操作を紹介

扱う話題は次の5つです。

* ファイルの変更監視
* ファイルロック
* ファイルのメモリへのマッピング
* 同期・非同期とブロッキング・ノンブロッキング
* select 属のシステムコールによるI/O 多重化

## 10.1 ファイルの変更監視（syscall.Inotify*）

* アクティブ方式
  * プログラムが定期的に見に行く
* パッシブ方式
  * OSに通知してもらう
<!--
Go言語の標準ライブラリではファイルの監視を簡単に行う機能は提供されていま
せん

パッシブな方式については、ファイルの変更検知が各OSでシステムコールやAPI
として提供されています。しかし、環境ごとのコードの差は大きくなります。 -->

```
たとえば、Linux ではinotify_init() 関数でファイルディスクリプタが取得でき、
inotify_add_watch()とinotify_rm_watch()で監視対象を追加したり外したりします。
これはファイルディスクリプタなので、通常のread() で変更情報を読み込んだり、close()で終了させます
```

それぞれの環境ごとに実装しようとすると長くなるため、
* ここではサードパーティーのパッケージである`gopkg.in/fsnotify.v1`を利用したパッシブな方式の例を説明
  * このすっきりしたコードの裏側では、Linux の場合はinotify 系API、BSD 系OS
    の場合はkqueue、Windows の場合はReadDirectoryChangesW をfsnotify ライ
    ブラリが内部で使い分けてくれるので、ファイルの変更が効率よく検知できます。

## 10.2 ファイルのロック（syscall.Flock()）

複数プロセス間でリソース競合しないように

システムコール syscall.Flock()

ロックモード

## 10.3 ファイルのメモリへのマッピング（syscall.Mmap()）

* マッピングすると, ファイルとメモリの内容を同期できる
    * メモリマップドファイルともよばれます
    * ランダムアクセスが高速

syscall.Mmap()をラップしたライブラリのひとつを用い、
ファイルをメモリにマッピングし、メモリを書き換え、書き戻す例：

```go
	// OpenFile(): 前章参照
	f, err := os.OpenFile(testPath, os.O_RDWR, 0644)
	if err != nil {
		panic(err)
	}
	defer f.Close()

    // mmap-goのMap()関数によりfの全内容をメモリにマップする
	m, err := mmap.Map(f, mmap.RDWR, 0)
	if err != nil {
		panic(err)
	}
	defer m.Unmap()

	m[9] = 'X'
    m.Flush()
```

* コピーオンライト
    * メモリ領域の操作モードの1つ. mmap.COPY
    * メモリ書き換えが発生すると、メモリ領域がまるごとコピーされ、もとのファイルには変更がない

## 10.4 同期・非同期／ブロッキング・ノンブロッキング

* IOタスク：「重い」
* 同期と非同期
    * 実データを取りに行くのか、通知をもらうのかで区別できます
    * 同期処理：OSにIOタスクを投げて、入出力の準備ができたら
    * 非同期処理：OSにIOタスクを投げて、入出力の準備ができたら、通知をもらう
* ブロッキング処理


## 10.5 select 属のシステムコールによるI/O 多重化
## 10.6 本章のまとめと次章予告